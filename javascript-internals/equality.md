비교
====
JS에서의 같음을 비교할 때 값이 정확하게 일치하는지를 따지기도 하지만 떄로는 아주 유사하다거나 교환 가능한지와 같이 좀 더 넓은 관점에서 비교하기도 함.   
그렇기 때문에 일치 비교(equality comparison)와 동등 비교(equivalence comparison)의 차이를 알고 있어야함.

일치 비교 (Equality comparison)
---
JS에서의 일치 연산자(===)는 비교하려는 대상의 타입이 다를 경우 타입을 강제로 변환하지 않고 비교를 수행하는 연산자임.   
즉, 타입이 서로 일치할 때의 대한 비교(수학적 동등성)를 다룸. 아래는 JS의 일치 비교 예시임.
```javascript
3 === 3.0;          // true
"yes" === "yes";    // true
null === null;      // true
false === false;    // true

42 === '42';        // false
true === 1;         // false
0 === null;         // false
"" === null;        // false
null === undefined; // false
```
```javascript
NaN === NaN;            // false
0 === -0;               // true

// 올바르게 비교하려면 아래와 같은 메서드를 사용할 것
Number.isNaN(NaN);      // true
Object.is(NaN, NaN);    // true
Object.is(0, -0);       // false
```
NaN은 Not-a-Number이 아니라 정확히 말하면 정의되지 않은 수치 연산의 결과임.   
IEEE-754(컴퓨터에서 실수를 표현하고 연산하는 방법을 표준화한 기술 규격) 규칙에서는 NaN은 어떤 값과도 같지 않음.(자기 자신 포함)   
NaN은 "값"이 아니라 오류 상태이므로 비교로 동일성을 판단하면 의미가 없어짐.   

-0과 같은 경우에도 IEEE-754 규칙에 의거하여 0에도 부호가 존재함.
```javascript
1 / Infinity;       // 0
1 / -Infinity       // -0

// JS에서의 === 규칙은 값의 수학적 동등성을 비교하므로
0 === -0;           // true
```
```javascript
[1, 2, 3] === [1, 2, 3];        // false
{ a: 42 } === { a: 42 };         // false
(x => x * 2) === (x => x * 2)   // false
```
원시 타입이 아닌 객체 타입에서의 비교는 조금 다름.  
각각의 배열 리터럴은 힙 영역에 서로 다른 배열 객체를 생성하고,  
=== 는 해당 객체의 내용이 아닌 스택(실행 컨텍스트)에 저장된 참조값을 비교하기 때문에 위와 같은 결과가 나옴.   
아래는 메모리 개념도임.
```text
Stack (Environment Record)
0xA100
0xB200

Heap
0xA100: [1,2,3]
0xB200: [1,2,3]
```

동등 비교(Equivalence comparison)
----
JS에서 == 연산자는 === 연산자와 유사한 방식으로 피연산자가 같은지 비교함.   
피연산자가 같은 타입이라고 가정하면 == 연산자와 === 연산자는 완전히 동일하게 작동함.   
단, 피연산자의 타입이 다른 경우 == 연산자는 비교 이전에 강제로 타입을 바꾸는 작업을 수행한다는 차이가 있음.   
아래는 동등 비교 연산자 예시임.
```javascript
42 == '42';     // true
1 == true;      // true

// 추가적으로 <,>,<=,>= 연산자도 타입 강제 변환이 일어남.
42 <= '42'      // true

// 단, 피연산자 모두가 문자열인 경우 사전처럼 알파벳순으로 문자열을 비교함.
"10" < "9"      // true
```